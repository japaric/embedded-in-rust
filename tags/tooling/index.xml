<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tooling on Embedded in Rust</title>
    <link>https://blog.japaric.io/tags/tooling/</link>
    <description>Recent content in tooling on Embedded in Rust</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a rel=&#34;license&#34; href=&#34;http://creativecommons.org/licenses/by/4.0/&#34;&gt;&lt;img alt=&#34;Creative Commons License&#34; src=&#34;https://i.creativecommons.org/l/by/4.0/80x15.png&#34; /&gt;&lt;/a&gt;&lt;br/&gt;Jorge Aparicio</copyright>
    <lastBuildDate>Sat, 13 Apr 2019 16:39:52 +0200</lastBuildDate><atom:link href="https://blog.japaric.io/tags/tooling/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>cargo-call-stack, part 2: getting call graph information from rustc</title>
      <link>https://blog.japaric.io/stack-analysis-2/</link>
      <pubDate>Sat, 13 Apr 2019 16:39:52 +0200</pubDate>
      
      <guid>https://blog.japaric.io/stack-analysis-2/</guid>
      <description>In a previous post I described the current implementation of cargo-call-stack, a static stack usage analysis tool. In the second part of that post I described the problems the tool runs into when dealing with indirect function calls (both function pointer calls and dynamic dispatch) and proposed improving the output of the tool by having rustc inject type information in the LLVM IR it produces.
While discussing that idea with rustc developers they noted that the compiler could emit information that&amp;rsquo;s more relevant to call graph analysis than just the signatures of functions and trait methods.</description>
    </item>
    
    <item>
      <title>Implementing a static stack usage analysis tool</title>
      <link>https://blog.japaric.io/stack-analysis/</link>
      <pubDate>Wed, 13 Mar 2019 20:09:57 +0100</pubDate>
      
      <guid>https://blog.japaric.io/stack-analysis/</guid>
      <description>(This blog covers the implementation details of cargo-call-stack v0.1.2. If you are only interested in using the tool these tweets and the README will give you an idea of what it can do.)
Motivation So, why would you ever want to analyze the stack usage of your program at compile time?
The obvious answer is when you want to know if your application can stack overflow at runtime without actually running your program.</description>
    </item>
    
    <item>
      <title>Rust your ARM microcontroller!</title>
      <link>https://blog.japaric.io/quickstart/</link>
      <pubDate>Fri, 28 Apr 2017 22:05:45 -0500</pubDate>
      
      <guid>https://blog.japaric.io/quickstart/</guid>
      <description>IMPORTANT! READ THIS!
Hello there! This article is outdated and following it will only confuse you. Check out the embedded Rust book and the rest of the embedded WG bookshelf for up to date and maintained documentation on embedded Rust development.
If you still want to read this post, for historical reasons and what now, scroll down.
 Want to program your microcontroller in Rust but your microcontroller vendor doesn&amp;rsquo;t provide a Rust HAL / SDK?</description>
    </item>
    
  </channel>
</rss>
