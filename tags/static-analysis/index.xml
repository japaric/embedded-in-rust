<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>static analysis on Embedded in Rust</title>
    <link>https://blog.japaric.io/tags/static-analysis/</link>
    <description>Recent content in static analysis on Embedded in Rust</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a rel=&#34;license&#34; href=&#34;http://creativecommons.org/licenses/by/4.0/&#34;&gt;&lt;img alt=&#34;Creative Commons License&#34; src=&#34;https://i.creativecommons.org/l/by/4.0/80x15.png&#34; /&gt;&lt;/a&gt;&lt;br/&gt;Jorge Aparicio</copyright>
    <lastBuildDate>Sat, 13 Apr 2019 16:39:52 +0200</lastBuildDate><atom:link href="https://blog.japaric.io/tags/static-analysis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>cargo-call-stack, part 2: getting call graph information from rustc</title>
      <link>https://blog.japaric.io/stack-analysis-2/</link>
      <pubDate>Sat, 13 Apr 2019 16:39:52 +0200</pubDate>
      
      <guid>https://blog.japaric.io/stack-analysis-2/</guid>
      <description>In a previous post I described the current implementation of cargo-call-stack, a static stack usage analysis tool. In the second part of that post I described the problems the tool runs into when dealing with indirect function calls (both function pointer calls and dynamic dispatch) and proposed improving the output of the tool by having rustc inject type information in the LLVM IR it produces.
While discussing that idea with rustc developers they noted that the compiler could emit information that&amp;rsquo;s more relevant to call graph analysis than just the signatures of functions and trait methods.</description>
    </item>
    
    <item>
      <title>Implementing a static stack usage analysis tool</title>
      <link>https://blog.japaric.io/stack-analysis/</link>
      <pubDate>Wed, 13 Mar 2019 20:09:57 +0100</pubDate>
      
      <guid>https://blog.japaric.io/stack-analysis/</guid>
      <description>(This blog covers the implementation details of cargo-call-stack v0.1.2. If you are only interested in using the tool these tweets and the README will give you an idea of what it can do.)
Motivation So, why would you ever want to analyze the stack usage of your program at compile time?
The obvious answer is when you want to know if your application can stack overflow at runtime without actually running your program.</description>
    </item>
    
  </channel>
</rss>
